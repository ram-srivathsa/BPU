//
// Generated by Bluespec Compiler, version 2017.07.A (build 1da80f1, 2017-07-21)
//
// On Thu Jun 14 11:24:56 IST 2018
//
//
// Ports:
// Name                         I/O  size props
// RDY_send_prediction_request_put  O     1 const
// prediction_response_get        O    59
// RDY_prediction_response_get    O     1
// RDY_ma_flush                   O     1
// RDY_ma_training                O     1
// CLK                            I     1 clock
// RST_N                          I     1 reset
// send_prediction_request_put    I    43
// ma_training_training_data      I   103
// EN_send_prediction_request_put  I     1
// EN_ma_flush                    I     1
// EN_ma_training                 I     1
// EN_prediction_response_get     I     1 unused
//
// No combinational paths from inputs to outputs
//
//

`ifdef BSV_ASSIGNMENT_DELAY
`else
  `define BSV_ASSIGNMENT_DELAY
`endif

`ifdef BSV_POSITIVE_RESET
  `define BSV_RESET_VALUE 1'b1
  `define BSV_RESET_EDGE posedge
`else
  `define BSV_RESET_VALUE 1'b0
  `define BSV_RESET_EDGE negedge
`endif

module mkbpu(CLK,
	     RST_N,

	     send_prediction_request_put,
	     EN_send_prediction_request_put,
	     RDY_send_prediction_request_put,

	     EN_prediction_response_get,
	     prediction_response_get,
	     RDY_prediction_response_get,

	     EN_ma_flush,
	     RDY_ma_flush,

	     ma_training_training_data,
	     EN_ma_training,
	     RDY_ma_training);
  input  CLK;
  input  RST_N;

  // action method send_prediction_request_put
  input  [42 : 0] send_prediction_request_put;
  input  EN_send_prediction_request_put;
  output RDY_send_prediction_request_put;

  // actionvalue method prediction_response_get
  input  EN_prediction_response_get;
  output [58 : 0] prediction_response_get;
  output RDY_prediction_response_get;

  // action method ma_flush
  input  EN_ma_flush;
  output RDY_ma_flush;

  // action method ma_training
  input  [102 : 0] ma_training_training_data;
  input  EN_ma_training;
  output RDY_ma_training;

  // signals for module outputs
  wire [58 : 0] prediction_response_get;
  wire RDY_ma_flush,
       RDY_ma_training,
       RDY_prediction_response_get,
       RDY_send_prediction_request_put;

  // register rg_pc_copy
  reg [31 : 0] rg_pc_copy;
  wire [31 : 0] rg_pc_copy$D_IN;
  wire rg_pc_copy$EN;

  // ports of submodule btb
  wire [45 : 0] btb$ma_update_update_val;
  wire [34 : 0] btb$mn_get;
  wire [31 : 0] btb$ma_put_pc;
  wire btb$EN_ma_flush,
       btb$EN_ma_put,
       btb$EN_ma_update,
       btb$RDY_ma_flush,
       btb$RDY_ma_update,
       btb$RDY_mn_get;

  // ports of submodule tage_predictor
  wire [55 : 0] tage_predictor$ma_train_training_data;
  wire [31 : 0] tage_predictor$ma_put_pc;
  wire [22 : 0] tage_predictor$mn_get;
  wire tage_predictor$EN_ma_flush,
       tage_predictor$EN_ma_put,
       tage_predictor$EN_ma_train,
       tage_predictor$RDY_ma_flush,
       tage_predictor$RDY_ma_train,
       tage_predictor$RDY_mn_get;

  // remaining internal signals
  wire [31 : 0] _theResult___fst_branch_pc__h423,
		_theResult___fst_branch_pc__h431;

  // action method send_prediction_request_put
  assign RDY_send_prediction_request_put = 1'd1 ;

  // actionvalue method prediction_response_get
  assign prediction_response_get =
	     { btb$mn_get[34] && tage_predictor$mn_get[22],
	       tage_predictor$mn_get,
	       btb$mn_get[34:32],
	       btb$mn_get[34] ?
		 _theResult___fst_branch_pc__h431 :
		 _theResult___fst_branch_pc__h423 } ;
  assign RDY_prediction_response_get =
	     btb$RDY_mn_get && tage_predictor$RDY_mn_get ;

  // action method ma_flush
  assign RDY_ma_flush = btb$RDY_ma_flush && tage_predictor$RDY_ma_flush ;

  // action method ma_training
  assign RDY_ma_training = tage_predictor$RDY_ma_train && btb$RDY_ma_update ;

  // submodule btb
  mkbtb btb(.CLK(CLK),
	    .RST_N(RST_N),
	    .ma_put_pc(btb$ma_put_pc),
	    .ma_update_update_val(btb$ma_update_update_val),
	    .EN_ma_put(btb$EN_ma_put),
	    .EN_ma_update(btb$EN_ma_update),
	    .EN_ma_flush(btb$EN_ma_flush),
	    .RDY_ma_put(),
	    .mn_get(btb$mn_get),
	    .RDY_mn_get(btb$RDY_mn_get),
	    .RDY_ma_update(btb$RDY_ma_update),
	    .RDY_ma_flush(btb$RDY_ma_flush));

  // submodule tage_predictor
  mkbranch tage_predictor(.CLK(CLK),
			  .RST_N(RST_N),
			  .ma_put_pc(tage_predictor$ma_put_pc),
			  .ma_train_training_data(tage_predictor$ma_train_training_data),
			  .EN_ma_put(tage_predictor$EN_ma_put),
			  .EN_ma_train(tage_predictor$EN_ma_train),
			  .EN_ma_flush(tage_predictor$EN_ma_flush),
			  .RDY_ma_put(),
			  .mn_get(tage_predictor$mn_get),
			  .RDY_mn_get(tage_predictor$RDY_mn_get),
			  .RDY_ma_train(tage_predictor$RDY_ma_train),
			  .RDY_ma_flush(tage_predictor$RDY_ma_flush));

  // register rg_pc_copy
  assign rg_pc_copy$D_IN = send_prediction_request_put[31:0] ;
  assign rg_pc_copy$EN = EN_send_prediction_request_put ;

  // submodule btb
  assign btb$ma_put_pc = send_prediction_request_put[31:0] ;
  assign btb$ma_update_update_val = ma_training_training_data[45:0] ;
  assign btb$EN_ma_put = EN_send_prediction_request_put ;
  assign btb$EN_ma_update =
	     EN_ma_training && !ma_training_training_data[102] ;
  assign btb$EN_ma_flush = EN_ma_flush ;

  // submodule tage_predictor
  assign tage_predictor$ma_put_pc = send_prediction_request_put[31:0] ;
  assign tage_predictor$ma_train_training_data =
	     (ma_training_training_data[102] ||
	      ma_training_training_data[69]) ?
	       ma_training_training_data[101:46] :
	       { ma_training_training_data[101:70],
		 1'd1,
		 ma_training_training_data[68:46] } ;
  assign tage_predictor$EN_ma_put = EN_send_prediction_request_put ;
  assign tage_predictor$EN_ma_train = EN_ma_training ;
  assign tage_predictor$EN_ma_flush = EN_ma_flush ;

  // remaining internal signals
  assign _theResult___fst_branch_pc__h423 = rg_pc_copy + 32'd4 ;
  assign _theResult___fst_branch_pc__h431 =
	     tage_predictor$mn_get[22] ?
	       btb$mn_get[31:0] :
	       _theResult___fst_branch_pc__h423 ;

  // handling of inlined registers

  always@(posedge CLK)
  begin
    if (RST_N == `BSV_RESET_VALUE)
      begin
        rg_pc_copy <= `BSV_ASSIGNMENT_DELAY 32'd0;
      end
    else
      begin
        if (rg_pc_copy$EN)
	  rg_pc_copy <= `BSV_ASSIGNMENT_DELAY rg_pc_copy$D_IN;
      end
  end

  // synopsys translate_off
  `ifdef BSV_NO_INITIAL_BLOCKS
  `else // not BSV_NO_INITIAL_BLOCKS
  initial
  begin
    rg_pc_copy = 32'hAAAAAAAA;
  end
  `endif // BSV_NO_INITIAL_BLOCKS
  // synopsys translate_on
endmodule  // mkbpu

